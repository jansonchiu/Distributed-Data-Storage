Creating Shards
- To create a shard, we initialized a dictionary that would map the shards with their associated nodes, keys would be the shard ids and values would be the list of node ids.
- Nodes are initially assigned to shards using the index from the list of all replicas, modded to the shard count (e.g. if shard count is 2, node assignments would alternate as we iterate through the list of replicas).

Adding a Node to a Shard
- Whichever node that receives a client request to add a new node to a shard, updates the local shard store, broadcasts the addition to all existing nodes, and sends the current key-value store to the new node.

Causal Consistency
- Whichever node that receives a client request, first checks if the request should be processed or queued. If it should be processed, then the node processes it, updates the VC, and broadcasts the updated VC to all nodes of all shards. If it should be queued, then the node queues it, and only does those steps after the request can be popped from the queue and processed.

Resharding
- Get the number of shards
- Create the new number of shards based on node count
- Since the resharding was local, we broadcast put request that tells all the other replicas to reshard.
- We make a for loop to go through the store and it checks if maps the key to a shard id.
- If the key’s associated shard id is not the current shard’s id,
- The request will be forwarded to one of the replicas in the respective shard’s key value store.
- After we forward the request, we delete it from the local store and check all the other replicas to delete the key if it is not part of the shard.
- If the key is in the right current shard id,
- It will delete the key from all the other shards that it is present.
- It then checks if the key is where it is supposed to be in the remaining shards.
- It is checked by seeing if the key belongs to another store or the local store.
- After this process is done, it forwards the shard store to every other shard to make sure that it is correct.
